//go:build !integration

package historitor

import (
	"github.com/stretchr/testify/require"
	"reflect"
	"testing"
	"time"
)

func TestNewConsumerGroup(t *testing.T) {
	GlobalConsumerGroupOptions = append(GlobalConsumerGroupOptions, WithConsumerGroupStartAt(StartFromEnd))
	defer func() {
		GlobalConsumerGroupOptions = GlobalConsumerGroupOptions[:len(GlobalConsumerGroupOptions)-1]
	}()
	cg := NewConsumerGroup(
		WithConsumerGroupName("group1"),
	)
	require.Equal(t, "group1", cg.name)
	require.Equal(t, StartFromEnd, cg.startAt)
	require.NotNil(t, cg.members)
	require.NotNil(t, cg.pel)
}

// TestNewConsumerGroup_default_members_different_addresses tests that Consumer groups created with NewConsumerGroup
// doesn't share the same members slice address.
//
// We do this using reflection to compare the map as pointers, instead of comparing the map contents or the map itself.
func TestNewConsumerGroup_default_members_different_addresses(t *testing.T) {
	cg1 := NewConsumerGroup(WithConsumerGroupName("cg1"))
	cg2 := NewConsumerGroup(WithConsumerGroupName("cg2"))

	require.False(t, reflect.ValueOf(cg1.members).Pointer() == reflect.ValueOf(cg2.members).Pointer(), "members slices should have different addresses")
}

func TestConsumerGroup_GetStartAt(t *testing.T) {
	cg := ConsumerGroup{
		startAt: StartFromEnd,
	}
	require.Equal(t, StartFromEnd, cg.GetStartAt())
}

func TestConsumerGroup_SetStartAt(t *testing.T) {
	cg := ConsumerGroup{}
	cg.SetStartAt(StartFromBeginning)
	require.Equal(t, StartFromBeginning, cg.startAt)
}

func TestConsumerGroup_GetName(t *testing.T) {
	cg := ConsumerGroup{
		name: "group1",
	}
	require.Equal(t, "group1", cg.GetName())
}

func TestConsumerGroup_AddMember(t *testing.T) {
	c1 := Consumer{name: "consumer1"}
	cg := ConsumerGroup{
		members: map[string]Consumer{
			"consumer1": {name: "otherconsumer"},
		},
	}
	cg.AddMember(c1)
	require.Equal(t, c1, cg.members["consumer1"])
}

func TestConsumerGroup_RemoveMember(t *testing.T) {
	c1 := Consumer{name: "consumer1"}
	cg := ConsumerGroup{
		members: map[string]Consumer{
			"consumer1": c1,
		},
	}
	cg.RemoveMember("consumer1")
	require.Equal(t, Consumer{}, cg.members["consumer1"])
}

func TestConsumerGroup_ListMembers(t *testing.T) {
	c1 := Consumer{name: "consumer1"}
	c2 := Consumer{name: "consumer2"}
	cg := ConsumerGroup{
		members: map[string]Consumer{
			"consumer1": c1,
			"consumer2": c2,
		},
	}
	require.ElementsMatch(t, []Consumer{c1, c2}, cg.ListMembers())
}

func TestConsumerGroup_GetMember(t *testing.T) {
	c1 := Consumer{name: "consumer1"}
	cg := ConsumerGroup{
		members: map[string]Consumer{
			"consumer1": c1,
		},
	}
	m, ok := cg.GetMember("consumer1")
	require.True(t, ok)
	require.Equal(t, c1, *m)
}

func TestConsumerGroup_GetMember_not_found(t *testing.T) {
	cg := ConsumerGroup{
		members: map[string]Consumer{
			"consumer1": {name: "consumer1"},
		},
	}
	_, ok := cg.GetMember("consumer2")
	require.False(t, ok)
}

func TestConsumerGroup_GetPendingEntry(t *testing.T) {
	cg := ConsumerGroup{
		pel: PendingEntriesList{
			fakeTestEntryID1: PendingEntry{
				ID:            fakeTestEntryID1,
				Consumer:      "consumer1",
				DeliveredAt:   time.Unix(0, 0).Add(time.Duration(1734467114191) * time.Millisecond).UTC(),
				DeliveryCount: 1,
			},
		},
	}
	pe, ok := cg.GetPendingEntry(fakeTestEntryID1)
	require.True(t, ok)
	require.Equal(t, cg.pel[fakeTestEntryID1], pe)
}

func TestConsumerGroup_GetPendingEntry_not_found(t *testing.T) {
	cg := ConsumerGroup{
		pel: PendingEntriesList{},
	}
	_, ok := cg.GetPendingEntry(fakeTestEntryID2)
	require.False(t, ok)
}

func TestConsumerGroup_GetPendingEntriesForConsumer(t *testing.T) {
	cg := ConsumerGroup{
		pel: PendingEntriesList{
			fakeTestEntryID1: PendingEntry{
				ID:            fakeTestEntryID1,
				Consumer:      "consumer1",
				DeliveredAt:   time.Unix(0, 0).Add(time.Duration(1734467114191) * time.Millisecond).UTC(),
				DeliveryCount: 1,
			},
			fakeTestEntryID2: PendingEntry{
				ID:            fakeTestEntryID2,
				Consumer:      "consumer2",
				DeliveredAt:   time.Unix(0, 0).Add(time.Duration(1734467114191) * time.Millisecond).UTC(),
				DeliveryCount: 1,
			},
			fakeTestEntryID3: PendingEntry{
				ID:            fakeTestEntryID3,
				Consumer:      "consumer1",
				DeliveredAt:   time.Unix(0, 0).Add(time.Duration(1734467114192) * time.Millisecond).UTC(),
				DeliveryCount: 1,
			},
		},
	}
	require.ElementsMatch(t, []PendingEntry{
		cg.pel[fakeTestEntryID1],
		cg.pel[fakeTestEntryID3],
	}, cg.GetPendingEntriesForConsumer("consumer1"))
}

func TestConsumerGroup_AddPendingEntry(t *testing.T) {
	cg := ConsumerGroup{
		pel: make(PendingEntriesList),
	}
	cg.AddPendingEntry(fakeTestEntryID1, "consumer1")
	require.Equal(t, PendingEntry{
		ID:            fakeTestEntryID1,
		Consumer:      "consumer1",
		DeliveredAt:   cg.pel[fakeTestEntryID1].DeliveredAt, // we can't predict the exact time
		DeliveryCount: 1,
	}, cg.pel[fakeTestEntryID1])

}

func TestConsumerGroup_AddPendingEntry_already_exists(t *testing.T) {
	fakeTime := time.Unix(0, 0).Add(time.Duration(1734467114191) * time.Millisecond).UTC()
	cg := ConsumerGroup{
		pel: PendingEntriesList{
			fakeTestEntryID1: PendingEntry{
				ID:            fakeTestEntryID1,
				Consumer:      "consumer1",
				DeliveredAt:   fakeTime,
				DeliveryCount: 1,
			},
		},
	}
	cg.AddPendingEntry(fakeTestEntryID1, "consumer1")
	require.Equal(t, PendingEntry{
		ID:            fakeTestEntryID1,
		Consumer:      "consumer1",
		DeliveredAt:   cg.pel[fakeTestEntryID1].DeliveredAt, // we can't predict the exact time
		DeliveryCount: 2,
	}, cg.pel[fakeTestEntryID1])
	require.NotEqual(t, fakeTime, cg.pel[fakeTestEntryID1].DeliveredAt)
}

func TestConsumerGroup_RemovePendingEntry(t *testing.T) {
	cg := ConsumerGroup{
		pel: PendingEntriesList{
			fakeTestEntryID1: PendingEntry{
				ID:            fakeTestEntryID1,
				Consumer:      "consumer1",
				DeliveredAt:   time.Unix(0, 0).Add(time.Duration(1734467114191) * time.Millisecond).UTC(),
				DeliveryCount: 1,
			},
		},
	}
	cg.RemovePendingEntry(fakeTestEntryID1)
	require.Equal(t, PendingEntry{}, cg.pel[fakeTestEntryID1])
}

func TestConsumerGroup_ListPendingEntries(t *testing.T) {
	cg := ConsumerGroup{
		pel: PendingEntriesList{
			fakeTestEntryID1: PendingEntry{
				ID:            fakeTestEntryID1,
				Consumer:      "consumer1",
				DeliveredAt:   time.Unix(0, 0).Add(time.Duration(1734467114191) * time.Millisecond).UTC(),
				DeliveryCount: 1,
			},
			fakeTestEntryID2: PendingEntry{
				ID:            fakeTestEntryID2,
				Consumer:      "consumer2",
				DeliveredAt:   time.Unix(0, 0).Add(time.Duration(1734467114191) * time.Millisecond).UTC(),
				DeliveryCount: 1,
			},
			fakeTestEntryID3: PendingEntry{
				ID:            fakeTestEntryID3,
				Consumer:      "consumer1",
				DeliveredAt:   time.Unix(0, 0).Add(time.Duration(1734467114192) * time.Millisecond).UTC(),
				DeliveryCount: 1,
			},
		},
	}
	aCopy := cg.ListPendingEntries()
	require.Equal(t, cg.pel, aCopy)
	aCopy[fakeTestEntryID1] = PendingEntry{}
	require.NotEqual(t, cg.pel, aCopy)
}

func TestConsumerGroup_MarshalBinary(t *testing.T) {
	expected := []byte{0x4e, 0x7f, 0x3, 0x1, 0x1, 0x15, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x1, 0xff, 0x80, 0x0, 0x1, 0x4, 0x1, 0x4, 0x4e, 0x61, 0x6d, 0x65, 0x1, 0xc, 0x0, 0x1, 0x7, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x1, 0xff, 0x84, 0x0, 0x1, 0x3, 0x50, 0x45, 0x4c, 0x1, 0xff, 0x8c, 0x0, 0x1, 0x7, 0x53, 0x74, 0x61, 0x72, 0x74, 0x41, 0x74, 0x1, 0xff, 0x86, 0x0, 0x0, 0x0, 0x2f, 0xff, 0x83, 0x4, 0x1, 0x1, 0x1e, 0x6d, 0x61, 0x70, 0x5b, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x5d, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x69, 0x74, 0x6f, 0x72, 0x2e, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x1, 0xff, 0x84, 0x0, 0x1, 0xc, 0x1, 0xff, 0x82, 0x0, 0x0, 0xa, 0xff, 0x81, 0x6, 0x1, 0x2, 0xff, 0x82, 0x0, 0x0, 0x0, 0x24, 0xff, 0x8b, 0x4, 0x1, 0x1, 0x12, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x4c, 0x69, 0x73, 0x74, 0x1, 0xff, 0x8c, 0x0, 0x1, 0xff, 0x86, 0x1, 0xff, 0x88, 0x0, 0x0, 0xa, 0xff, 0x85, 0x6, 0x1, 0x2, 0xff, 0x86, 0x0, 0x0, 0x0, 0x44, 0xff, 0x87, 0x3, 0x1, 0x2, 0xff, 0x88, 0x0, 0x1, 0x4, 0x1, 0x2, 0x49, 0x44, 0x1, 0xff, 0x86, 0x0, 0x1, 0x8, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x1, 0xc, 0x0, 0x1, 0xb, 0x44, 0x65, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x65, 0x64, 0x41, 0x74, 0x1, 0xff, 0x8a, 0x0, 0x1, 0xd, 0x44, 0x65, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x1, 0x4, 0x0, 0x0, 0x0, 0x10, 0xff, 0x89, 0x5, 0x1, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x0, 0x0, 0xfe, 0x1, 0x6d, 0xff, 0x80, 0x1, 0x6, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x31, 0x1, 0x1, 0x9, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x31, 0x37, 0x27, 0xff, 0x8d, 0x3, 0x1, 0x1, 0x10, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x1, 0xff, 0x8e, 0x0, 0x1, 0x1, 0x1, 0x4, 0x4e, 0x61, 0x6d, 0x65, 0x1, 0xc, 0x0, 0x0, 0x0, 0xe, 0xff, 0x8e, 0x1, 0x9, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x31, 0x0, 0x1, 0x1, 0x58, 0x2f, 0xff, 0x8f, 0x3, 0x1, 0x1, 0xf, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x49, 0x44, 0x1, 0xff, 0x90, 0x0, 0x1, 0x2, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x1, 0x3, 0x53, 0x65, 0x71, 0x1, 0x6, 0x0, 0x0, 0x0, 0x10, 0xff, 0x89, 0x5, 0x1, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x0, 0x0, 0x16, 0xff, 0x90, 0x1, 0xf, 0x1, 0x0, 0x0, 0x0, 0xe, 0xde, 0xf3, 0xd5, 0x2a, 0xb, 0x62, 0x6d, 0xc0, 0xff, 0xff, 0x1, 0x1, 0x0, 0x1, 0x58, 0x2f, 0xff, 0x8f, 0x3, 0x1, 0x1, 0xf, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x49, 0x44, 0x1, 0xff, 0x90, 0x0, 0x1, 0x2, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x1, 0x3, 0x53, 0x65, 0x71, 0x1, 0x6, 0x0, 0x0, 0x0, 0x10, 0xff, 0x89, 0x5, 0x1, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x0, 0x0, 0x16, 0xff, 0x90, 0x1, 0xf, 0x1, 0x0, 0x0, 0x0, 0xe, 0xde, 0xf3, 0xd5, 0x2a, 0xb, 0x62, 0x6d, 0xc0, 0xff, 0xff, 0x1, 0x1, 0x0, 0x1, 0x9, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x31, 0x1, 0xf, 0x1, 0x0, 0x0, 0x0, 0xe, 0xde, 0xf3, 0xd5, 0x2a, 0xb, 0x62, 0x6d, 0xc0, 0xff, 0xff, 0x1, 0x2, 0x0, 0x1, 0x48, 0x2f, 0xff, 0x8f, 0x3, 0x1, 0x1, 0xf, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x49, 0x44, 0x1, 0xff, 0x90, 0x0, 0x1, 0x2, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x1, 0x3, 0x53, 0x65, 0x71, 0x1, 0x6, 0x0, 0x0, 0x0, 0x10, 0xff, 0x89, 0x5, 0x1, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x0, 0x0, 0x6, 0xff, 0x90, 0x2, 0xff, 0x80, 0x0, 0x0}
	cg := ConsumerGroup{
		name: "group1",
		members: map[string]Consumer{
			"consumer1": {name: "consumer1"},
		},
		pel: PendingEntriesList{
			fakeTestEntryID1: PendingEntry{
				ID:            fakeTestEntryID1,
				Consumer:      "consumer1",
				DeliveredAt:   time.Unix(0, 0).Add(time.Duration(1734467114191) * time.Millisecond).UTC(),
				DeliveryCount: 1,
			},
		},
		startAt: StartFromBeginning,
	}
	b, err := cg.MarshalBinary()
	require.NoError(t, err)
	require.Equal(t, expected, b)
}

func TestConsumerGroup_UnmarshalBinary(t *testing.T) {
	input := []byte{0x4e, 0x7f, 0x3, 0x1, 0x1, 0x15, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x1, 0xff, 0x80, 0x0, 0x1, 0x4, 0x1, 0x4, 0x4e, 0x61, 0x6d, 0x65, 0x1, 0xc, 0x0, 0x1, 0x7, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x1, 0xff, 0x84, 0x0, 0x1, 0x3, 0x50, 0x45, 0x4c, 0x1, 0xff, 0x8c, 0x0, 0x1, 0x7, 0x53, 0x74, 0x61, 0x72, 0x74, 0x41, 0x74, 0x1, 0xff, 0x86, 0x0, 0x0, 0x0, 0x2f, 0xff, 0x83, 0x4, 0x1, 0x1, 0x1e, 0x6d, 0x61, 0x70, 0x5b, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x5d, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x69, 0x74, 0x6f, 0x72, 0x2e, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x1, 0xff, 0x84, 0x0, 0x1, 0xc, 0x1, 0xff, 0x82, 0x0, 0x0, 0xa, 0xff, 0x81, 0x6, 0x1, 0x2, 0xff, 0x82, 0x0, 0x0, 0x0, 0x24, 0xff, 0x8b, 0x4, 0x1, 0x1, 0x12, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x4c, 0x69, 0x73, 0x74, 0x1, 0xff, 0x8c, 0x0, 0x1, 0xff, 0x86, 0x1, 0xff, 0x88, 0x0, 0x0, 0xa, 0xff, 0x85, 0x6, 0x1, 0x2, 0xff, 0x86, 0x0, 0x0, 0x0, 0x44, 0xff, 0x87, 0x3, 0x1, 0x2, 0xff, 0x88, 0x0, 0x1, 0x4, 0x1, 0x2, 0x49, 0x44, 0x1, 0xff, 0x86, 0x0, 0x1, 0x8, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x1, 0xc, 0x0, 0x1, 0xb, 0x44, 0x65, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x65, 0x64, 0x41, 0x74, 0x1, 0xff, 0x8a, 0x0, 0x1, 0xd, 0x44, 0x65, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x1, 0x4, 0x0, 0x0, 0x0, 0x10, 0xff, 0x89, 0x5, 0x1, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x0, 0x0, 0xfe, 0x1, 0x6d, 0xff, 0x80, 0x1, 0x6, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x31, 0x1, 0x1, 0x9, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x31, 0x37, 0x27, 0xff, 0x8d, 0x3, 0x1, 0x1, 0x10, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x1, 0xff, 0x8e, 0x0, 0x1, 0x1, 0x1, 0x4, 0x4e, 0x61, 0x6d, 0x65, 0x1, 0xc, 0x0, 0x0, 0x0, 0xe, 0xff, 0x8e, 0x1, 0x9, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x31, 0x0, 0x1, 0x1, 0x58, 0x2f, 0xff, 0x8f, 0x3, 0x1, 0x1, 0xf, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x49, 0x44, 0x1, 0xff, 0x90, 0x0, 0x1, 0x2, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x1, 0x3, 0x53, 0x65, 0x71, 0x1, 0x6, 0x0, 0x0, 0x0, 0x10, 0xff, 0x89, 0x5, 0x1, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x0, 0x0, 0x16, 0xff, 0x90, 0x1, 0xf, 0x1, 0x0, 0x0, 0x0, 0xe, 0xde, 0xf3, 0xd5, 0x2a, 0xb, 0x62, 0x6d, 0xc0, 0xff, 0xff, 0x1, 0x1, 0x0, 0x1, 0x58, 0x2f, 0xff, 0x8f, 0x3, 0x1, 0x1, 0xf, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x49, 0x44, 0x1, 0xff, 0x90, 0x0, 0x1, 0x2, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x1, 0x3, 0x53, 0x65, 0x71, 0x1, 0x6, 0x0, 0x0, 0x0, 0x10, 0xff, 0x89, 0x5, 0x1, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x0, 0x0, 0x16, 0xff, 0x90, 0x1, 0xf, 0x1, 0x0, 0x0, 0x0, 0xe, 0xde, 0xf3, 0xd5, 0x2a, 0xb, 0x62, 0x6d, 0xc0, 0xff, 0xff, 0x1, 0x1, 0x0, 0x1, 0x9, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x72, 0x31, 0x1, 0xf, 0x1, 0x0, 0x0, 0x0, 0xe, 0xde, 0xf3, 0xd5, 0x2a, 0xb, 0x62, 0x6d, 0xc0, 0xff, 0xff, 0x1, 0x2, 0x0, 0x1, 0x48, 0x2f, 0xff, 0x8f, 0x3, 0x1, 0x1, 0xf, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x49, 0x44, 0x1, 0xff, 0x90, 0x0, 0x1, 0x2, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x1, 0x3, 0x53, 0x65, 0x71, 0x1, 0x6, 0x0, 0x0, 0x0, 0x10, 0xff, 0x89, 0x5, 0x1, 0x1, 0x4, 0x54, 0x69, 0x6d, 0x65, 0x1, 0xff, 0x8a, 0x0, 0x0, 0x0, 0x6, 0xff, 0x90, 0x2, 0xff, 0x80, 0x0, 0x0}
	cg := ConsumerGroup{}
	err := cg.UnmarshalBinary(input)
	require.NoError(t, err)
	require.Equal(t, "group1", cg.name)
	require.Equal(t, StartFromBeginning, cg.startAt)
	require.Equal(t, "consumer1", cg.members["consumer1"].name)
	require.ElementsMatch(t, []PendingEntry{
		{
			ID:            fakeTestEntryID1,
			Consumer:      "consumer1",
			DeliveredAt:   time.Unix(0, 0).Add(time.Duration(1734467114191) * time.Millisecond).UTC(),
			DeliveryCount: 1,
		},
	}, cg.GetPendingEntriesForConsumer("consumer1"))

}

func TestConsumerGroup_UnmarshalBinary_error(t *testing.T) {
	input := []byte("invalid")
	cg := ConsumerGroup{}
	err := cg.UnmarshalBinary(input)
	require.Error(t, err)
}
